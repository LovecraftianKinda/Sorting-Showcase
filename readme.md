# Sorting Algorithm Showcase

## Development Goals

- Implement various sorting algorithms.
- Compare the performance of different sorting algorithms.
- Visually represent the sorting process for each algorithm.

## Sorting Algorithms

1. **Bubble Sort**
    - Simple comparison-based algorithm.
    - Repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.

2. **Selection Sort**
    - Divides the input list into two parts: a sorted and an unsorted region.
    - Repeatedly selects the smallest (or largest) element from the unsorted region and moves it to the sorted region.

3. **Insertion Sort**
    - Builds the final sorted list one item at a time.
    - Takes each element from the input and finds the correct position within the sorted part of the list.

4. **Merge Sort**
    - A divide-and-conquer algorithm.
    - Divides the list into two halves, recursively sorts them, and then merges the sorted halves.

5. **Quick Sort**
    - Another divide-and-conquer algorithm.
    - Picks an element as a pivot and partitions the list around the pivot, recursively sorting the partitions.

6. **Heap Sort**
    - Converts the list into a heap data structure.
    - Repeatedly extracts the maximum element from the heap and rebuilds the heap.

## Visual Representation

- Use graphical tools to animate the sorting process.
- Highlight the comparisons and swaps made by each algorithm.
- Show the progression of the list from unsorted to sorted.

## Performance Comparison

- Measure the time complexity of each algorithm.
- Compare the number of comparisons and swaps.
- Analyze the best, average, and worst-case scenarios for each algorithm.

## Conclusion

- Summarize the strengths and weaknesses of each sorting algorithm.
- Provide recommendations for which algorithms to use in different scenarios.