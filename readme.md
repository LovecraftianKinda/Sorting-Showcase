# Sorting Algorithm Showcase

## Development Goals

- Implement various sorting algorithms.
- Compare the performance of different sorting algorithms.
- Visually represent the sorting process for each algorithm.

## Sorting Algorithms

1. **Bubble Sort**
    - Average Time Complexity : O(n^2) ~ bad one
2. **Selection Sort**
    - Average Time Complexity : O(n^2) ~ better than bubble sort
3. **Insertion Sort**
    - Average Time Complexity : O(n^2) ~ about as good as selection sort but stable too
4. **Merge Sort**
    - Average Time Complexity : O(n log(n)) ~ divide and conquer algorithm that divides the array in half recursively and merges the subarrays sorting them in the process
5. **Quick Sort**
    - Average Time Complexity : O(n log(n)) ~ uses a pivot to divide and conquer
6. **Heap Sort**
    - Average Time Complexity : O(n log(n)) ~ uses the heap data structure to sort the array
7. **Counting Sort**
    - Average Time Complexity : O(n + k) ~ for integers only, fast as fuck
8. **Radix Sort**
    - Average Time Complexity : O(nk) ~ looks pretty neat, integers only

## Visual Representation

- Use graphical tools to animate the sorting process.
- Highlight the comparisons and swaps made by each algorithm.
- Show the progression of the list from unsorted to sorted.

## Performance Comparison

- Measure the time complexity of each algorithm.
- Plot the time complexity graph for each algorithm.
- Analyze the best, average, and worst-case scenarios for each algorithm.

## Conclusion

- Provide recommendations for which algorithms to use in different scenarios.
